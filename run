#!/usr/bin/env node

env = process.env
env.QML2_IMPORT_PATH='.'
env.QSG_RENDER_LOOP='threaded'
env.QT_SCALE_FACTOR='2'

const Brig = require('brig');
brig = new Brig();

brig.on('ready', function(brig) {

    const cp = require('child_process');

    let audioThreads = []
    const controlsCache = {}
    var Ohm = brig.createType('Ohm', {
	property: {'main':null},
	method: {
	    'updateControl(id,val)': function(id,val) {
		for (let i = 0; i < audioThreads.length; i++) {
		    audioThreads[i].subproc.send(`controls[${id}]=${val}`)
		    controlsCache[id] = val
		}
	    }
	}
    });
    
    var AudioThread = brig.createType('AudioThread', {
	property: { eqnL: '0', eqnR: '0' }, signal: ['kill()']
    });
    
    AudioThread.on('instance-created', function(instance) {
	audioThreads.push(instance)
	instance.subproc = cp.fork('./ohm.js');
	for (let id in controlsCache)
	    instance.subproc.send(`controls[${id}]=${controlsCache[id]}`);
	instance.on('eqnLChanged', function() {
	    instance.subproc.send('streams[0]='+instance.getProperty('eqnL'));
	});
	instance.on('eqnRChanged', function() {
	    instance.subproc.send('streams[1]='+instance.getProperty('eqnR'));
	});
	instance.on('kill', function() {
	    instance.subproc.kill('SIGHUP');
	    audioThreads = audioThreads.filter(thread=>thread != instance)
	    console.error('sent kill signal to audio thread');
	});
    });

    var root = brig.createComponent();
    root.setData("import ohm 1.0; import Brig.Ohm 1.0; Ohm {main: OhmStudio {}}");
    var errors = root.native.errors();
    if (errors.length) console.log(errors);
    var view = root.create();

});
