#!/usr/bin/env node

env = process.env
env.QML2_IMPORT_PATH='.'
env.QSG_RENDER_LOOP='threaded'
env.QT_SCALE_FACTOR='2'

const Brig = require('brig');
brig = new Brig();
brig.on('ready', function(brig) {
    const cp = require('child_process');
    let audioThreads = []
    const controlsCache = {}

    var Ohm = brig.createType('Ohm', {
	property: {'main':null},
	method: {
	    'updateControl(id,val)': function(id,val) {
		for (let i = 0; i < audioThreads.length; i++) {
		    audioThreads[i].subproc.send(`controls[${id}]=${val}`)
		    controlsCache[id] = val
		}
	    }
	},
	signal: ['kill()']
    });

    let ohminstance = null;
    Ohm.on('instance-created', function (instance) {
    	ohminstance = instance
	instance.on('kill', function() {
	    ohminstance = null;
	    for (let thread of audioThreads)
	       thread.subproc.kill('SIGHUP')
	    process.exit(0);
	});
    });

    var AudioThread = brig.createType('AudioThread', {
	property: { eqnL: '0', eqnR: '0' }, signal: ['kill()']
    });

    AudioThread.on('instance-created', function(instance) {
	audioThreads.push(instance)
	console.error('creating audio thread');
	instance.subproc = cp.fork('./ohm.js');
	for (let id in controlsCache)
	    instance.subproc.send(`controls[${id}]=${controlsCache[id]}`);
	instance.on('eqnLChanged', function() {
	    instance.subproc.send('streams[0]='+instance.getProperty('eqnL'));
	});
	instance.on('eqnRChanged', function() {
	    instance.subproc.send('streams[1]='+instance.getProperty('eqnR'));
	});
	instance.on('kill', function() {
	    instance.subproc.kill('SIGHUP');
	    audioThreads = audioThreads.filter(thread=>thread != instance)
	    console.error('sent kill signal to audio thread');
	});
    });

    brig.open('ohm/OhmStudio.qml', function(err, window) {
        if (err) console.error(err)
    });

});
